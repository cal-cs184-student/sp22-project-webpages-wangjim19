<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Alan Zhu, Jim Wang</h2>

<div>

<h2 align="middle">LINK TO WEBPAGE: https://cal-cs184-student.github.io/sp22-project-webpages-wangjim19/proj2/index.html </h2>
  
<h2 align="middle">Overview</h2>
<p>
  In this project, we wrote code to draw curves and surfaces and manipulate meshes.
  We applied different techniques learned in lecture such as de Casteljau's algorithm for computing Bezier curves and area-weighted normals, as well as mesh manipulation techniques.
  This project really helped us better understand how smooth surfaces and curves are computed in graphics, and it solidified the idea of meshes to represent 3d geometries, and the data sturcutres used to implement them.
  We found the representation of triangle meshes very interesting, and we are glad to have gained firsthand experience in how different operations can be implemented using the halfedge representation.
</p>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<p>
  De Casteljau's algorithm is a recursive method for evaluating a point (chosen by parameter t) along a Bezier curve parametrized by some points.
  We implemented it by using a series of linear interpolations between each two consecutive points to generate n-1 new points. This is then applied recursively until we narrow down to one point.
  
</p>

<div align="middle">
  <table style="width=100%">
    <img src="./bzc1.png" align="middle" width="600px"/>
    <figcaption align="middle">6 point Bezier curve</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc2.png" align="middle" width="600px"/>
    <figcaption align="middle">Step 1</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc3.png" align="middle" width="600px"/>
    <figcaption align="middle">Step 2</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc4.png" align="middle" width="600px"/>
    <figcaption align="middle">Step 3</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc5.png" align="middle" width="600px"/>
    <figcaption align="middle">Step 4</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc6.png" align="middle" width="600px"/>
    <figcaption align="middle">Step 5</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./bzc7.png" align="middle" width="600px"/>
    <figcaption align="middle">Slightly different curve</figcaption>
  </table>
</div>


<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau</h3>

<p>
  To compute a point on a bezier surface, we parametrize by u and v. We take the nxn grid of 3d points and apply de Casteljau on each row with u, then apply it on the resulting points with v.
  We implemented it using 3 helper functions: the first does the same as part 1, the second calls the firat recursively on a 1d array of points, and the 3rd calls the second on each row, then on the final array.
</p>

<div align="middle">
  <table style="width=100%">
    <img src="./bez.png" align="middle" width="600px"/>
    <figcaption align="middle">Screenshot of bez/teapot.bez</figcaption>
  </table>
</div>
  
<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-weighted vertex normals</h3>
  
<p>
  We looped through the faces by iteratively getting halfedge->twin->next, which gives us the next adjacent halfedge to the vertex. 
  For each face, we use the vertices to construct two vectors along the edges, and get the cross-product to get the area-weighted normal. 
  We then sum these up and divide by the total area (sums of magnitudes of the cross-products) to get the final result.
</p>
  
<div align="middle">
  <table style="width=100%">
    <img src="./without-normals.png" align="middle" width="600px"/>
    <figcaption align="middle">Teapot shading without normals</figcaption>
  </table>
</div>
  
<div align="middle">
  <table style="width=100%">
    <img src="./with-normals.png" align="middle" width="600px"/>
    <figcaption align="middle">Teapot shading with normals</figcaption>
  </table>
</div>


<h3 align="middle">Part 4: Edge flip</h3>
  
<p>
  We first retrieved all of the relevant vertices, faces, and half-edges. Then, we set the half-edge for each vertex and face appropriately, then set the next and vertex of the flipped halfedges, and then the next and face of the other halfedges along the two faces.
  To debug, we tried writing out each of the class members of each modified element and comparing this to a diagram we drew. We also tried changing things like positions of points to verify that we were referencing the correct points.
  In the end, weird pointer/address things were the most difficult for us to debug.
</p>
  
<div align="middle">
  <table style="width=100%">
    <img src="./before-flips.png" align="middle" width="600px"/>
    <figcaption align="middle">Teapot before edge flips</figcaption>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <img src="./after-flips.png" align="middle" width="600px"/>
    <figcaption align="middle">Teapot after edge flips</figcaption>
  </table>
</div>


</body>
</html>
